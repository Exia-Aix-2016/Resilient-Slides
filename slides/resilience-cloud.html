<section >

  <!--INTRO-->
  <section data-background-image="https://i.imgur.com/LcrrGy8.png">
    <h2 style="text-align: left; margin-left: -16%;">
      Les technologies <br />
      résilientes  <br />
      du cloud computing
    </h2>
    <aside class="notes">
      COmme la expliqué quentin,
      <br />
      La démocratisation des services <br />
      L'augmentation du nombre de client

    </aside>
  </section>


  <section>
    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Mod%C3%A8le-client-serveur.svg/1200px-Mod%C3%A8le-client-serveur.svg.png"/>
    <aside data-markdown class="notes">
     Internet c'est le branchement de millier de réseau <br />
     proposant des millions de services.
     <br />
     Pour Proposer une ressource, il faut aborder la manière donc vous <br />
     Accedez à ces ressources
     <br />
     Le client requêtes une ressource et le serveur répond à celle-ci
    </aside>
  </section>

<!--Technologies-->
<section>
  <h2 style="margin-top: auto;">
    Technologies & Techniques
  </h2>
  <img style=" width: 55%;" src="/images/cartographyresilience.png">
  <aside data-markdown class="notes">
  Au cours de ces années des technologies plus innovantes 
  les unes que les autres ont vu le jour dans le but de répondre
  à des problèmes d'ordre de résilience

  *Les conditions défavorables sont des états internes ou externes 
  aux systèmes qui peuvent perturber ou conduire à la perturbation 
  des capacités critiques.

  *Les événements indésirables sont des incidents qui perturbent les 
  capacités critiques en causant des dommages aux biens associés.

  </aside>
</section>



<!--Répondre à la demande-->
<section data-background-image="https://i.imgur.com/LcrrGy8.png">
  <h2 style="text-align: left; margin-left: -16%;">
    Répondre <br /> à la demande
  </h2>
  <aside data-markdown class="notes">

    Dans un premier temps les entreprises proposer ces ressources <br />
    en centralisant le stockage et le traitement sur un immense serveur central.
    <br /> 
    Pensez maintenant : l'augmentation du nombre d'utilisation, implique sur le serveur

    DIRE QU'IL CRASH SA RACE !


  </aside>
</section>

<!--Scalabilité-->
<section>

  <h2>
    Scalabilité
  </h2>
  
  <img style=" width: 55%;" src="/images/scalability.png">
  <aside data-markdown class="notes">
  - Parler des deux approches
  <br />
  - Parler des limites...
  Pour horizontal : c'est aussi applicatif.
  <br />
  
  



  </aside>
</section>

<!--LoadBalancing-->
<section>
  <h2>
    Répartition de charge
  </h2>
  <div style="margin-left: -16%; display: flex; width: 130%;">
    <div>
      <h3> Statique</h3>
      <img  src="/images/dnsroundrobin.png">
    </div>
    <div style="width: 5px; margin: 6px 0; background: black;"></div>
    <div>
      <h3> Dynamique</h3>
      <img  src="/images/proxying.png">
    </div>
  </div>
  
  <aside data-markdown class="notes">
    Sauf que cette approche est static, une application par serveur
    <br />
    il serait d'autant plus efficace si il était possible de répartir sur non serveur
    notre application selon les besoins sur les serveurs.
    <br />
    De plus en cas de problème sur un serveur, il serait biens
    de pouvoir retiré facilement l'application et la déplacer sur un autre
    
  </aside>
</section>

<!--Virtualisation-->
<section>
  <h2>
    Virtualisation
  </h2>
  <img style="width: 55%;"   src="/images/virtualisation.png">

  <aside data-markdown class="notes">
  La virtualisation permets de résoudre ça 
  <br />
  Expliquer
  <br />
  Avant, les applications adoptaient une 
  architecture monolithique qui, bien que simple à déployer, 
  était compliquée à gérer quand déployées sur le même serveur.

  <br />
  Utilisation optimale des ressources du parc informatique.
  <br />
  Installation, déploiement, migration facilité des applications du système d'information.
  <br />
  Economie matériel et énergétique en mutualisant les ressources.
  <br />
  Permet de mettre en place des environnements de testes pour les équipes de développement, ce qui améliore la qualité.
  <br />
  Sécurisation des systèmes grâce à l'isolation des systèmes hôte et des réseaux.
  <br />
  Allocation dynamique des ressources allouées aux systèmes virtualisés.
  
  <br />

  Cependant une machine virtuel c'est un comme je l'ai dit un système en entier qui est virtualiser
  <br />
  De plus les machine virtuelle fonctionne grâce à des logiciel de virtualisation, <br />
  une vm d'un logiciel A ne tourne pas sur un logiciel B
  
  <br />
  Bien qu'on soit capable de répartir grace à la virtualisation nos app, c'est lourd, c'est long, ça consomme beraucoup.



  </aside>
</section>
<!--Conteneurisation-->
<section data-background-image="https://i.imgur.com/g187lW0.png">
  
  <h2 style="margin-top: -10%;">
    Conteneurisation
  </h2>

  <img style="float: right; width: 50%;" src="/images/containervsvirtua.png">
    




  <aside data-markdown class="notes">
    
     Pour résoudre ces problèmatiques on a inventé la conteneurisation
     <br />
     L'idée n'est plus de virtualiser le système mais l'application.
     <br />
     La containeisation vise à répondre à ces problème

     <br />
    

  Standardisation : L'instar des conteneurs dans la vrai vie, grâce à ça on peut augmenter la DENSITER d'application dans notre système

  Légèreté : Les conteneurs partagent le même noyau système, celui de la machine, il n'y a aucun système virtualisé nécessaire à les faire fonctionner, cela demande moins de ressources au serveur. De plus, contrairement à une machine virtuelle standard, un conteneur mettra beaucoup moins de temps à démarrer.

  Scalable : La scalabilité est facilitée, puisqu'il est facile de dupliquer un conteneur.

  Sécurisé : Les applications sont isolées les unes des autres, ce qui empêche en principe la transmission d'un code malveillant à un autre conteneur ou à l'hôte.   

  </aside>
</section>


<!--Clusterisation-->
<section >
  <h2>
    Clusterisation
  </h2>
  <img style="width: 50%;"  src="/images/cluster.png">

  <aside data-markdown class="notes">

    Afin de toujours répondre à la demande et améliorer la résilience de notre système.
    <br />

    Les ingénieurs on penser à :
    <br />

     <br />

     Facilité de management
     <br />

     Augmentation de la disponibilité

     <br />

     *Baisse des coûts
      <br />

     *La scalabilité horizontale
      <br />

    * La haute disponibilité ou tolérance aux pannes 

      
  
  </aside>
</section>

<!--Orchestration-->
<section >
  <h2>
    Orchestration
  </h2>
  <img style="width: 50%;"   src="/images/orchestration.png">

  <aside data-markdown class="notes">

    Cependant grâce on conteneur et leur avantage, l'augmentation du nombre de conteneur 
    <br />
    implique des probleme de gestion - avant c'était manuel
    <br />
    Du coup pour automatiser ça on a inventer l'orchestration
    <br />


  L'orchestration permet d'automatiser le déploiement
  et la gestion de la mise à l'échelle (scalabilité)
  et la mise en réseau des conteneurs.

  L'orchestrateur va s'occuper de répartir les conteneurs 


    mise à jour - rolling update, rollback

  Les conteneurs étant par nature volatile, les informations réseau 
  de chaque conteneur (ex: adresse IP) est variable. L'orchestrateur
  offre un niveau d'abstraction permettant de regrouper un ou plusieurs 
  conteneurs, de leur allouer une adresse IP fixe et de l'exposer 
  à d'autres conteneurs.
  Ces fonctions confèrent à l'infrastructure un niveau de résilience accru.

  </aside>
</section>


<!--Architecture micro-service-->
<section >
  <h2>
    Architecture micro-service
  </h2>
  <img style="width: 70%;"   src="/images/archimicroservices.png">

  <aside data-markdown class="notes">

    En 2011 apparait le concept d'architecture
     micro-service, la philosophie s'inspire
      grandement de celle d'UNIX : "Ne faire qu'une seule chose et la faire bien". 
      L'idée n'est plus de structurer l'application en un seul bloc, 
      mais de découpler ses modules en un ensemble de services, 
      ces derniers communiquant ensemble par le biais d'interfaces
       commun.

       <br />

       L'approche offre des avantages conséquents, elle facilite 
       le développement distribué, réduit les cycles de développement 
       puisque les équipes peuvent livrer chaque service indépendamment 
       des autres, facilite le déploiement, 
       <br />

       augmente la résilience : le faible couplage 
       entre les services permet qu'en cas de dysfonctionnement d'un des services que 
       l'application reste opérationnel.

    Grâce à l'utilisation de conteneurs et d'orchestrateurs, il devient facile pour l'organisme 
    de déployer selon ses besoins, l'ensemble des micro-services sur son infrastructure.

  </aside>
</section>

<!--Réseau de diffusion de contenu-->
<section >
  <h2>
    Réseau de diffusion de contenu
  </h2>
  <img style="width: 80%;"   src="/images/cdn.png">

  <aside data-markdown class="notes">

    Vers la fin des années 90' la technologie de 
    réseau de diffusion de contenu est créé, 
    constituée d'ordinateur en réseau, reliés 
    à travers internet ils coopèrent afin de mettre 
    à disposition le contenu d'un serveur principal.

    A noter : Si le serveur principal est tombé, le contenu est accessible.
  </aside>
</section>

<!--La suite-->
<section data-background-image="https://i.imgur.com/LcrrGy8.png">

  <h2 style="text-align: left; margin-left: -16%;">
    En Résumé...
  </h2>
  <aside data-markdown class="notes">
    Nous avons vue les technologies permettant de supporter 
    <br />
    la charge toujours grandissante, cependant ces technologies
    <br />
    bien qu'inovantes comporte des problèmes,
    <br />
    problèmes qui seront présenté par Denis, après la pause de 10min.
    <br />
    Je vous remercie.
  </aside>
</section>
</section>